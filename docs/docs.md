# Полная документация к Secure Transfer Protocol (STP)

## 1. Модуль `compression.Compression`

### Обзор
Класс для сжатия и распаковки данных с поддержкой нескольких алгоритмов. Используется для оптимизации объема передаваемых данных.

### Методы

#### `compress(data: str, algorithm: str = "gzip") -> str`
- **Назначение**: Сжимает строковые данные выбранным алгоритмом
- **Параметры**:
  - `data` - строка для сжатия
  - `algorithm` - алгоритм сжатия (gzip, zlib, bz2)
- **Возвращает**: Base64-кодированную строку сжатых данных
- **Исключения**:
  - `ValueError` - если указан неподдерживаемый алгоритм
  - `Exception` - при ошибках сжатия
- **Пример**:
  ```python
  compressed = Compression.compress("большие данные", "gzip")
  ```

#### `decompress(data: str, algorithm: str = "gzip") -> str`
- **Назначение**: Распаковывает сжатые данные
- **Параметры**:
  - `data` - Base64-кодированная строка сжатых данных
  - `algorithm` - алгоритм, которым были сжаты данные
- **Возвращает**: Распакованную исходную строку
- **Исключения**:
  - `ValueError` - если указан неподдерживаемый алгоритм
  - `Exception` - при ошибках распаковки
- **Пример**:
  ```python
  original = Compression.decompress(compressed, "gzip")
  ```

## 2. Модуль `cryptographing`

### Класс `Nonce`

#### Обзор
Управляет генерацией и верификацией одноразовых чисел (nonce) для защиты от атак повторного воспроизведения.

#### Методы
- `generate_nonce() -> str`: Генерирует криптографически безопасный nonce (128-символьный хеш)
- `verify_nonce(nonce: str) -> bool`: Проверяет валидность nonce
- `add_nonce(nonce: str) -> None`: Добавляет использованный nonce в множество

### Класс `Crypting`

#### Обзор
Центральный криптографический модуль, реализующий:
- Управление ключами (Dilithium5)
- Шифрование/дешифрование (AES-256-CBC)
- Цифровые подписи
- Генерацию HMAC
- Управление идентификацией узлов

#### Основные методы

1. **Управление ключами**:
   - `generate_dilithium_keys() -> Tuple[str, str]`: Генерация новой пары ключей
   - `load_or_generate_keys() -> Tuple[str, str]`: Загрузка или генерация ключей
   - `write_keys(private_key: str, public_key: str) -> None`: Сохранение ключей
   - `read_keys() -> Tuple[str, str]`: Чтение ключей из файлов

2. **Операции с данными**:
   - `sign_message(private_key: str, message: str) -> str`: Подпись сообщения
   - `verify_signature(public_key: str, message: str, signature: str) -> bool`: Проверка подписи
   - `crypt(key: str, data: str, hmac_key: str) -> str`: Шифрование с HMAC
   - `decrypt(key: str, data: str, hmac_key: str) -> Optional[str]`: Дешифрование с проверкой HMAC

3. **Идентификация**:
   - `generate_hwid() -> str`: Генерация аппаратного ID
   - `create_my_peer_info() -> Dict`: Создание информации о текущем узле
   - `load_my_peer_info() -> Dict`: Загрузка информации о текущем узле
   - `load_another_peer_info() -> Dict`: Загрузка информации о удаленном узле

## 3. Модуль `logger.STPLogger`

### Обзор
Кастомный логгер с цветным выводом и поддержкой различных уровней логирования.

### Уровни логирования:
- `debug()`: Отладочная информация (белый)
- `info()`: Информационные сообщения (зеленый)
- `warning()`: Предупреждения (желтый)
- `error()`: Ошибки (красный)
- `critical()`: Критические ошибки (белый на красном)

### Формат вывода:
`[время] | [имя логгера] | [уровень] | [сообщение]`

## 4. Модуль `time_sync.Time`

### Обзор
Синглтон для точной синхронизации времени с NTP-серверами.

### Основные методы:
- `get_time() -> float`: Текущее время в UNIX-формате
- `get_formatted_time() -> str`: Форматированная строка времени
- `stop()`: Остановка фоновой синхронизации

### Особенности:
- Автоматическая синхронизация с 5 серверами
- Фоновая ресинхронизация каждые 10 минут
- Микросекундная точность


### 5. Модуль `transmission.Transmission`

#### Конструктор
```python
__init__(is_server: bool = False, host: str = "127.0.0.1", port: int = 12345, target_ip: Optional[str] = None)
```
- **Параметры**:
  - `is_server`: Режим работы (True для сервера, False для клиента)
  - `host`: IP-адрес для подключения/прослушивания
  - `port`: Порт соединения
  - `target_ip`: Ожидаемый IP-адрес пира (опциональная верификация)

#### Метод `init()`
**Логика работы**:
1. Создает TCP-сокет
2. Загружает/генерирует ключи Dilithium5
3. Загружает peer-информацию (HWID и публичные ключи)
4. Инициализирует синхронизацию времени
5. Для сервера - привязывает сокет к порту

**Ошибки**:
- `Exception` с деталями при проблемах инициализации

#### Метод `handshake()`
**4-этапный процесс**:

1. **HWID Verification**:
   - Обмен аппаратными идентификаторами
   - Проверка соответствия сохраненному HWID
   - Использование nonce для защиты от replay-атак

2. **Key Exchange (Level 1)**:
   - Генерация ephemeral ключей Kyber1024
   - Подпись сообщений Dilithium5
   - Установка первого ключа шифрования

3. **Key Exchange (Level 2)**:
   - Повторная генерация ключей Kyber1024
   - Создание второго ключа шифрования
   - Дополнительная верификация подписей

4. **HMAC Key Setup**:
   - Обмен ключом для HMAC
   - Обеспечение целостности сообщений

**Особенности**:
- Каждый этап содержит временные метки
- Все сообщения подписываются
- Используются одноразовые nonce

#### Метод `send(data: str, ...)`
**Поток обработки**:
1. Сжатие (если включено и данные >4KB)
2. Двойное шифрование:
   - AES-256-CBC с первым ключом
   - AES-256-CBC со вторым ключом
3. Подпись сообщения
4. Добавление HMAC
5. Надежная передача:
   - Сначала отправляется размер пакета
   - Ожидается подтверждение (ACK)
   - Передача основного содержимого

**Параметры**:
- `compress`: Флаг сжатия (по умолчанию True)
- `compress_algorithm`: Выбор алгоритма (gzip/zlib/bz2)

#### Метод `recv()`
**Процесс приема**:
1. Получение размера пакета
2. Отправка ACK
3. Получение основного содержимого
4. Проверки:
   - Валидность nonce
   - Подпись сообщения
   - Целостность HMAC
5. Дешифрование:
   - Уровень 2 -> Уровень 1
6. Распаковка (если нужно)

**Возвращает**:
- Раскодированные данные или None при END_SESSION

#### Метод `close()`
**Процедура закрытия**:
1. Отправка уведомления END_SESSION
2. Закрытие сокетов
3. Очистка ключей из памяти
4. Остановка синхронизации времени

### Особенности реализации

**Безопасность**:
1. Защита от MITM:
   - Верификация HWID
   - Проверка подписей Dilithium5
2. Защита от replay-атак:
   - Одноразовые nonce
   - Временные метки
3. Постквантовая криптография:
   - Dilithium5 для подписей
   - Kyber1024 для обмена ключами

**Производительность**:
- Оптимальное сжатие (>4KB данных)
- Пакетная передача
- Асинхронные операции:
  - Синхронизация времени
  - Ресинхронизация NTP

### Примеры использования

#### 1. Простая передача данных
```python
# Сервер
server = Transmission(is_server=True, target_ip="192.168.1.100")
server.init()
server.handshake()
data = server.recv()  # Получаем данные
server.send("Response")  # Отправляем ответ
server.close()

# Клиент
with Transmission(host="192.168.1.1", target_ip="192.168.1.100") as client:
    client.handshake()
    client.send("Hello!")
    print(client.recv())  # Печатаем ответ
```

#### 2. Передача больших данных
```python
def send_file(filename: str, connection: Transmission):
    with open(filename, 'r') as f:
        data = f.read()
    connection.send(data, compress_algorithm="bz2")

# На принимающей стороне
received = connection.recv()  # Автоматически распакует
```

#### 3. Работа с бинарными данными
```python
# Отправка
binary_data = bytes_data.decode('latin1')
conn.send(binary_data, compress=False)

# Прием
received = conn.recv().encode('latin1')
```

### Рекомендации по использованию

1. **Безопасность**:
   - Всегда используйте `target_ip` для верификации
   - Регулярно обновляйте peer-информацию
   - Храните ключи в защищенном месте

2. **Производительность**:
   - Для больших данных используйте bz2 сжатие
   - Отключайте сжатие для маленьких пакетов (<4KB)
   - Используйте контекстный менеджер (`with`)

3. **Надежность**:
   - Обрабатывайте все исключения
   - Всегда явно закрывайте соединения
   - Проверяйте статус handshake перед передачей

### Типовые сценарии ошибок

1. **Ошибка верификации IP**:
   ```python
   try:
       conn = Transmission(target_ip="192.168.1.100")
       conn.handshake()
   except ConnectionAbortedError as e:
       print(f"IP verification failed: {e}")
   ```

2. **Ошибка handshake**:
   ```python
   if not conn.handshake_pass:
       print("Handshake failed!")
       conn.close()
   ```

3. **Ошибка передачи данных**:
   ```python
   try:
       conn.send(large_data)
   except Exception as e:
       print(f"Send failed: {e}")
       conn.close()
   ```

