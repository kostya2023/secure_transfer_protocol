# Документация на все функции

## 1. `compression.Compression`
Этот класс позволяет удобно сжимать и разжимать данные. 
Имеет 2 функции:

 1. Функция `compress`:
     - Сжимает с помощью 3 алогритмов на выбор: `gzip`, `zlib`, `bz2`. перед возвратом, кодирует результат в `base64`.
     - Вход `str`, выход `str`
 2. Функция `decompress`:
     - Разжимает данные с помощью 3 алгоритмов на выбор: `gzip`, `zlib`, `bz2`, тут уже надо самому ставить, чем было сжато, тем надо и разжать.
     - Вход `str`, выход `str`

## 2. `cryptographing.Crypting`
Класс для выполнения криптографических операций, включая генерацию ключей, шифрование/дешифрование, подпись/верификацию сообщений и управление идентификацией узлов.

### Методы:

1. **`generate_hwid() -> str`**  
   - Генерирует уникальный аппаратный идентификатор (HWID) на основе системной информации.
   - Использует SHA-256 для хеширования данных.
   - Возвращает: HEX-строку с HWID (64 символа).
   - Особенности: При ошибке использует криптографически безопасные случайные данные.

2. **`create_my_peer_info() -> Dict`**  
   - Создает словарь с информацией о текущем узле.
   - Содержит: HWID, отпечаток публичного ключа, сам ключ, временную метку и системную информацию.
   - Логирует критические ошибки.

3. **`save_my_peer_info() -> str`**  
   - Сохраняет информацию о узле в файл `my_peer.json`.
   - Возвращает имя файла при успехе.
   - Автоматически вызывает `create_my_peer_info()`.

4. **`load_my_peer_info() -> Dict`**  
   - Загружает информацию из `my_peer.json`.
   - Если файла нет — создает новый.
   - Проверяет обязательные поля: `HWID`, `public_key_fingerprint`, `public_key`, `created_at`.

5. **`load_another_peer_info() -> Dict`**  
   - Загружает и верифицирует информацию о другом узле из `another_peer.json`.
   - Проверяет соответствие отпечатка публичного ключа (SHA-256).

6. **`hash(data: str) -> str`**  
   - Хеширует строку алгоритмом SHA-256.
   - Возвращает HEX-строку (64 символа).

7. **`write_keys(private_key: str, public_key: str) -> None`**  
   - Сохраняет ключи в файлы `private_key.pem` и `public_key.pem`.
   - Логирует успех/ошибки.

8. **`read_keys() -> Tuple[str, str]`**  
   - Читает ключи из файлов.  
   - Возвращает: `(приватный_ключ, публичный_ключ)`.
   - Вызывает `FileNotFoundError` если файлов нет.

9. **`generate_dilithium_keys() -> Tuple[str, str]`**  
   - Генерирует новую пару ключей алгоритмом Dilithium5.
   - Возвращает: `(публичный_ключ, приватный_ключ)`.

10. **`load_or_generate_keys() -> Tuple[str, str]`**  
    - Проверяет наличие файлов с ключами. Если нет — генерирует новые.
    - Возвращает: `(приватный_ключ, публичный_ключ)`.

11. **`sign_message(private_key: str, message: str) -> str`**  
    - Подписывает сообщение алгоритмом Dilithium5.
    - Возвращает: подпись в бинарном формате.

12. **`verify_signature(public_key: str, message: str, signature: str) -> bool`**  
    - Проверяет подпись сообщения.
    - Возвращает: `True` если подпись верна.

13. **`generate_hmac(key: str, data: str) -> str`**  
    - Генерирует HMAC-SHA512 для данных.
    - Ключ и результат кодируются в Base64.

14. **`crypt(key: str, data: str, hmac_key: str) -> str`**  
    - Шифрует данные AES-256-CBC с PKCS7-падингом.
    - Формат пакета: `шифртекст|IV|HMAC` (все в Base64).
    - Генерирует случайный IV (16 байт).

15. **`decrypt(key: str, data: str, hmac_key: str) -> Optional[str]`**  
    - Дешифрует пакет, проверяет HMAC.
    - Возвращает: исходные данные или `None` при ошибке.
    - Логирует попытки подмены данных.

### Особенности:
- Все методы логируют операции через `STPLogger`.
- Используемые алгоритмы:
  - Асимметричная криптография: Dilithium5 (постквантовая)
  - Симметричное шифрование: AES-256-CBC
  - Хеширование: SHA-256, SHA-512 (для HMAC)
- Ключи и данные передаются в виде строк (Base64 для бинарных данных).


## 3. `logger.STPLogger`
Кастомный логгер для Secure Transfer Protocol с цветным выводом в консоль. Реализует стандартные уровни логирования с визуальным выделением.

### Конструктор:
- **`__init__(name="STP_logger")`**
  - Инициализирует логгер с указанным именем
  - Устанавливает уровень логирования `DEBUG` (максимальная детализация)
  - Настраивает:
    - Цветной формат вывода (с использованием Colorama)
    - Выход в stdout

### Методы логирования:
1. **`debug(message)`**
   - Логирует сообщение уровня DEBUG (белый цвет)
   - Для детальной отладочной информации

2. **`info(message)`**
   - Логирует информационное сообщение (зеленый цвет)
   - Для стандартных операций

3. **`warning(message)`**
   - Логирует предупреждение (желтый цвет)
   - Для не критичных проблем

4. **`error(message)`**
   - Логирует ошибку (красный цвет)
   - Для серьезных проблем

5. **`critical(message)`**
   - Логирует критическую ошибку (белый текст на красном фоне)
   - Для фатальных ошибок

### Внутренние методы:
- **`_log(level, message)`**
  - Базовый метод логирования с применением цветов
  - Параметры:
    - `level`: строковый уровень логирования ('DEBUG', 'INFO' и т.д.)
    - `message`: текст сообщения

### Особенности:
- Использует библиотеку Colorama для кроссплатформенной работы с цветами
- Формат вывода:
  ```
  [время] | [имя логгера] | [уровень] | [сообщение]
  ```
- Все сообщения автоматически сбрасывают стиль после вывода (`Style.RESET_ALL`)
- Поддерживает стандартные уровни логирования Python

### Цветовая схема:
| Уровень    | Цвет                |
|------------|---------------------|
| DEBUG      | Белый               |
| INFO       | Зеленый             |
| WARNING    | Желтый              |
| ERROR      | Красный             |
| CRITICAL   | Белый на красном фоне |

Логгер автоматически добавляет обработчик вывода в консоль при инициализации.


## 4. `time_sync.Time`
Синглтон-класс для синхронизации и управления временем с NTP-серверами. Обеспечивает точное время даже при рассинхронизации системных часов.

### Конструктор:
- Реализован через `__new__` с потокобезопасным singleton-паттерном
- Автоматически запускает фоновую синхронизацию при первом создании

### Основные методы:

1. **`get_time() -> float`**  
   - Возвращает текущее время в UNIX-формате (секунды с эпохи)  
   - Использует комбинацию NTP-времени и высокоточного perf_counter()  
   - Точность: микросекунды  

2. **`get_formatted_time() -> str`**  
   - Возвращает отформатированную строку времени  
   - Формат: `YYYY-MM-DD HH:MM:SS.µµµµµµ`  
   - Пример: `2023-05-15 14:30:45.123456`  

3. **`stop()`**  
   - Останавливает фоновую синхронизацию  
   - Рекомендуется вызывать при завершении работы приложения  

### Внутренние методы:

- **`_sync_with_ntp()`**  
  - Синхронизирует время с одним из 5 публичных NTP-серверов  
  - Приоритет серверов: Google, NTP Pool, Microsoft, Apple, Cloudflare  
  - При ошибках всех серверов использует системное время  

- **`_resync_loop()`**  
  - Фоновый поток для периодической повторной синхронизации  
  - Интервал по умолчанию: 10 минут  

### Особенности:
- Потокобезопасная реализация (использует threading.Lock)
- Автоматический fallback на системное время при недоступности NTP
- Поддерживает микросекундную точность
- Логирует все операции через STPLogger
- Работает в фоновом потоке (daemon mode)

### Пример использования:
```python
# Получить точное время
timestamp = Time.get_time()  # 1684152645.123456
formatted = Time.get_formatted_time()  # "2023-05-15 14:30:45.123456"

# При завершении приложения
Time().stop()
```

### Конфигурация:
- Интервал ресинхронизации: 600 секунд (10 минут)
- Таймаут запроса к NTP: 2 секунды
- Используемые серверы (в порядке приоритета):
  1. time.google.com
  2. pool.ntp.org
  3. time.windows.com
  4. time.apple.com
  5. time.cloudflare.com



## 5. `transmission.Transmission`
Класс для защищенной передачи данных с использованием многоуровневого шифрования и квантово-безопасных алгоритмов. Реализует полный цикл безопасного соединения.

### Конструктор:
```python
__init__(is_server: bool = False, host: str = "127.0.0.1", port: int = 12345)
```
- `is_server`: Флаг серверного режима
- `host`: IP-адрес для подключения/прослушивания
- `port`: Порт для соединения

### Основные методы:

1. **`init()`**  
   Инициализирует соединение:
   - Создает сокет
   - Загружает/генерирует ключи Dilithium
   - Загружает информацию о пирах
   - Инициализирует синхронизацию времени

2. **`handshake()`**  
   Выполняет 4-этапный квитирование:
   1. Проверка HWID
   2. Обмен ключами Kyber (уровень 1)
   3. Обмен ключами Kyber (уровень 2) 
   4. Обмен HMAC-ключом (уровень 3)

3. **`send(data: str, compress=True, compress_algorithm="gzip") -> bool`**  
   Отправляет данные с:
   - Опциональным сжатием (если данные >4KB)
   - Двойным шифрованием (AES-256-CBC)
   - Подписью сообщения
   - Контролем целостности (HMAC)

4. **`recv() -> Optional[str]`**  
   Принимает данные, выполняя:
   - Проверку подписи
   - Двойное дешифрование
   - Распаковку (если нужно)
   - Возвращает `None` при получении END_SESSION

5. **`close()`**  
   Безопасно закрывает соединение:
   - Отправляет END_SESSION
   - Закрывает сокеты
   - Очищает ключи

6. **`get_connection_info() -> dict`**  
   Возвращает статус соединения:
   ```python
   {
       "handshake_completed": bool,
       "peer_hwid": str,
       "keys_established": bool
   }
   ```

### Контекстный менеджер:
```python
with Transmission() as t:
    t.send("data")
    data = t.recv()
```
Автоматически вызывает `init()` и `close()`

### Внутренние методы:

- **`_server_handshake()`**  
  Серверная часть квитирования (4 этапа)
  
- **`_client_handshake()`**  
  Клиентская часть квитирования (4 этапа)

### Особенности:

**Безопасность:**
- Квантово-безопасные алгоритмы (Dilithium + Kyber)
- 3 уровня ключей:
  1. Основной ключ шифрования
  2. Дополнительный ключ шифрования  
  3. HMAC-ключ для контроля целостности
- Подпись всех сообщений
- Верификация HWID

**Надежность:**
- Контроль размера пакетов
- Подтверждение получения (ACK)
- Таймстампинг всех операций
- Автоматическое восстановление при ошибках

**Производительность:**
- Опциональное сжатие (gzip/zlib/bz2)
- Пакетная передача больших данных
- Фоновые операции

### Пример использования:
```python
# Сервер
server = Transmission(is_server=True)
server.init()
server.handshake()
server.send("Hello client")
data = server.recv()
server.close()

# Клиент 
with Transmission() as client:
    client.handshake()
    client.send("Hello server")
    print(client.recv())
```

### Логирование:
Все операции логируются через `STPLogger` с указанием:
- Этапа работы
- Размеров данных
- Криптографических операций
- Ошибок и предупреждений